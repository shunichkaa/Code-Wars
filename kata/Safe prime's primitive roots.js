// Introduction
// Prime number p is safe prime if number (p - 1) / 2 is also prime.
//
// 	Consider all residues x modulo n, for which gcd(x, n) = 1. This set is called multiplicative group of residues modulo n.
//
// 	In certain cases that group is cyclic (in prime modulo case, for example), which means it generated by powers of some element.
//
// 	Task
// Your task is to find the smallest generator of multiplicative group of residues, if given modulus is safe prime. Otherwise return -1.
//
// Modulus will not exceed 128 bits.
//
// 	There is more general version of this problem.
//
// 	Restrictions
// require is not allowed and most builtins are frozen.


function modPow(base, exp, mod) {
	let result = 1n;
	let b = base % mod;
	let e = exp;

	while (e > 0n) {
		if (e & 1n) result = (result * b) % mod;
		b = (b * b) % mod;
		e >>= 1n;
	}
	return result;
}

function millerRabinTest(d, n, a) {
	let x = modPow(a, d, n);
	if (x === 1n || x === n - 1n) return true;
	while (d !== n - 1n) {
		x = (x * x) % n;
		d <<= 1n;
		if (x === 1n) return false;
		if (x === n - 1n) return true;
	}
	return false;
}

function isPrime(n) {
	if (n < 2n) return false;
	if (n === 2n || n === 3n) return true;
	if (n % 2n === 0n) return false;

	// Найдём d, такое что n-1 = d * 2^r, d нечётно
	let d = n - 1n;
	while (d % 2n === 0n) {
		d /= 2n;
	}

	// Множество "хороших" баз для 64-бит (и 128 бит с вероятностью)
	const testBases = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n];

	for (let a of testBases) {
		if (a >= n - 1n) break;
		if (!millerRabinTest(d, n, a)) return false;
	}
	return true;
}

function findGenerator(n) {
	if (typeof n !== 'bigint') return -1n;

	if (!isPrime(n)) return -1n;

	const q = (n - 1n) / 2n;

	if (!isPrime(q)) return -1n;

	for (let g = 2n; g < n; g++) {
		if (modPow(g, q, n) !== 1n && modPow(g, 2n, n) !== 1n) {
			return g;
		}
	}
	return -1n;
}
